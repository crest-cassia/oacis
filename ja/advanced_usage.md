---
layout: default
title: "高度な使い方"
lang: ja
next_page: cli
---

# {{ page.title }}

---

## スケジューラを経由してジョブを実行する

xsub(https://github.com/crest-cassia/xsub) というスケジューララッパを経由してTorqueなどのスケジューラにジョブを投入する方法について説明する。
xsubは各ホストごとのスケジューラの差異を吸収する。

xsubの各ホストへの導入方法については、xsubのREADMEを参照のこと。
またxsubの実行コマンドへのPATHを、bashrcでセットする必要がある。（ログインシェルがzshなどの他のシェルの場合でも）
OACISがxsubの実行時に `bash -l` コマンドを経由して、bashのログインシェルとして実行するためである。

### 実行例（Torqueを経由してジョブを実行する場合）

ここでは例としてMPIで並列化しているシミュレータを、Torqueのスケジューラを使って占有時間を指定して実行することを考える。

シミュレータを実行するホストの環境変数XSUB_TYPEに"torque"を指定する。（たとえば，.bashrcに `export XSUB_TYPE="torque"` を記載する。）
Hostを作成し、スケジューラの変数（占有するノード数 `ppn` 、 使用時間 `walltime` ）がHost Parametersに登録されているのを確認する。
Runの作成時にHostを選択すると、スケジューラの変数の値入力が求められる。
Runの作成時に要求されるスケジューラの変数は、`mpi_procs`, `omp_threads`, `ppn`, `walltime` の４つである。
例えば、各ノード４スレッドで、８ノードのMPI/OpenMPハイブリッド並列化プログラムを、実行時間10:00:00で実行する場合、
i_procs=8, omp_threads=4, ppn=4, walltime="10:00:00" を指定する。
するとxsubが、Torque用のジョブカードを作成しジョブを実行する。

![ホストパラメータの指定]({{ site.baseurl }}/images/new_run_with_host_params.png){:width="400px"}

### MPI, OpenMPのジョブ

Simulator登録時に、 *Suppot MPI*, *Support OMP* のチェックを入れると、Runの作成時にプロセス数とスレッド数を指定するフィールドが表示されるようになる。

![並列数の指定]({{ site.baseurl }}/images/new_run_mpi_omp_support.png){:width="400px"}

OpenMPのジョブのスレッド数を指定すると、ジョブスクリプトの中で OMP_NUM_THREADS の環境変数がセットされる。
つまりOpenMPで並列化しているシミュレータはOMP_NUM_THREADS環境変数を参照してスレッド数を決めるように実装されていなければならない。
（ プログラム内で *omp_set_num_threads()* 関数で別途指定している場合は、当然ながらここで指定したスレッド数は適用されない）

MPIで並列化して実行する場合、Runの作成時に指定したプロセス数は OACIS_MPI_PROCS の環境変数にセットされる。
Simulatorの実行コマンドで *mpiexec -n $OACIS_MPI_PROCS simulator.out* というように OACIS_MPI_PROCS 環境変数を参照してコマンドを実行するようにする。

### 京コンピュータを利用するケース

京コンピュータでジョブを実行する場合、実行するシミュレーターのファイルもステージングする必要があるため、実行コマンドを絶対パスやホームディレクトリからの相対パスで指定する事はできない。
そこで、プリプロセスを使って実行ファイルをカレントディレクトリにコピーし、実行コマンドはカレントディレクトリからの相対パスで指定するようにする。

実行ファイルが `~/path/to/simulator.out` にある場合、プリプロセスには以下のように書く

```
cp ~/path/to/simulator.out .
```

xsubで実行すると、各ワークディレクトリがステージインされるので、必要なファイルはすべてカレントディレクトリに事前にコピーしておく。

実行コマンドは以下のように書く

```
./simulator.out
```

このように設定しておけば、xsubがカレントディレクトリを丸ごとステージインして実行してくれる。
実行結果は、他のホストの場合と同様にカレントディレクトリ以下に配置しておけば、ステージアウトして結果を取り込んでくれるので、特にステージアウトするファイルを指定する必要は無い。

## 手動でジョブを実行する

OACIS上でRunを作るとworkerによってジョブ投入が自動で行われるが、ジョブの実行を手動で行う事もできる。
Run作成時に手動実行を指定した場合、自動ジョブ投入は行われずジョブスクリプトの生成のみ行われる。
そのジョブスクリプトをユーザーが手動で実行し、結果を後からOACISに取り込む事が可能である。

手動で実行することにより、手間は増えるが細かなスクリプトのカスタマイズが可能である。
例えば、以下の様な用途に利用できる。

- 複数のRunを一つのジョブとしてスケジューラに投入する場合
    - スケジューラのジョブ数に制限がある場合などにまとめて投入する事ができる
        - 例：京のバルクジョブ
- スケジューラの制限時間よりも長いジョブを実行する場合
    - 一度の実行ではジョブが完了せずジョブのリスタートが必要になる場合には、一つのRunに対して複数回ジョブ投入が必要になる
- スケジューラに投入するジョブスクリプトに特殊な設定が必要な場合
    - OACISによって生成されたスクリプトを手動で編集する事によって、実効方法をカスタマイズできる

手動実行を行うためにはRunの作成時に投入Host選択フィールドで "manual submission" を選択する。
Runの作成後に `${OACIS_ROOT}/public/Result_development/manual_submission` ディレクトリにシェルスクリプトが生成される。
パラメータの入力形式がJSON形式の場合には、入力用JSONファイルも作成される。

![並列数の指定]({{ site.baseurl }}/images/manual_submission.png){:width="400px"}

ユーザーが以下のように生成されたジョブスクリプト実行すると、ジョブが実行される。

```
bash 52cde935b93f969b07000005.sh
```

シミュレーション実行結果のファイル（今回の例の場合 52cde935b93f969b07000005.tar.bz2）は以下のコマンドでデータベースに取り込む事ができる。

```
./bin/oacis_cli job_include -i 52cde935b93f969b07000005.tar.bz2
```

上記コマンドの入力ファイルはスペース区切りまたはコンマ区切りで複数ファイルを指定できる。


## 結果をMongoDB内に格納する

通常シミュレータが出力したファイル群はそのままファイルとしてサーバー上に保存されるが、結果をMongoDB内に保存することもできる。
結果をMongoDB内に保存しておくと後で結果の値に対してクエリをかけることができる。
例えば、様々なジョブを実行したあとに結果がある値近傍のParameterSetを列挙するといったことができる。

結果をDB内に保存するためには、保存したいデータをJsonフォーマットでシミュレータから出力すればよい。
`_output.json` という名前でカレントディレクトリ直下にJSONを作成すれば、データベースへの格納時にファイルがパースされDB内に保存される。

格納された結果は以下のようにブラウザから閲覧可能である。

![並列数の指定]({{ site.baseurl }}/images/run_results.png){:width="400px"}

ただし、ドット（.）を含む文字列はキーとして使用できない。（MongoDBの制約）"."を含んでいるとジョブがfailedになるので注意。

## シミュレーターのバージョンを記録する

シミュレーションの実行時にどのバージョンのシミュレーターで実行したかOACISに記録をさせておくことができる。
RunとSimulatorのバージョンをひもづけて記録する事により、例えば、あるバージョンの実行結果の一括削除などの操作ができる様になる。

バージョンを保存するには、Simulatorのバージョンを出力させるコマンドをOACISに登録する。
例えば

```
~/path/to/simulator.out --version
```

というコマンドでバージョン情報を出力するシミュレーターがある場合、このコマンドをSimulator登録時に "Print version command" というフィールドに入力する。
このコマンドを登録しておくと、ジョブスクリプトの中でこのコマンドを実行しその標準出力をバージョンとして記録することができる。

Print version command の標準出力に出力された文字列がバージョンとして認識されるので、実行バイナリに引数を渡すだけでなく柔軟な指定が可能である。
例えば、以下のように手動でタグをつけたり、ビルドログを出力したり、バージョン管理システムのコミットIDを出力するような利用方法も考えられる。

```
echo "v1.0.0"
```
```
cat ~/path/to/build_log.txt
```
```
cd ~/path/to; git describe --always
```

## プリプロセスの定義

シミュレータによっては実際にシミュレーションジョブを開始する前に、入力ファイルを準備したりフォーマットを調整したりするプリプロセスが必要な場合がしばしばある。
しかしプリプロセスを計算ジョブの中で行おうとすると以下のようなケースで問題になる。

- スクリプト言語など入力ファイルの準備に使うプログラムが計算ノードにインストールされていないケース
- 外部へのネットワークが遮断され入力用ファイルを準備するために外部からファイルを転送することができないケース
- ファイルのステージングの都合により、ジョブの実行前にファイルをすべて用意する必要があるケース

そこで、OACISにはジョブの実行前にプリプロセスを個別に実行する仕組みを用意してある。
このプリプロセスはジョブの投入前にログインノードで実行されるため上記の問題は起きない。
ここではプリプロセスの仕様と設定方法を説明する。

プリプロセスはジョブの投入前にworkerによってssh経由で実行される。
workerの実行手順は

1. 各Runごとにワークディレクトリを作成する
1. SimulatorがJSON入力の場合、_input.jsonを配置する。
1. Simulatorの *pre_process_script* フィールドに記載されたジョブスクリプトをワークディレクトリに配置し実行権限をつける。(_preprocess.sh というファイル名で配置される)
1. _preprocess.sh をワークディレクトリをカレントディレクトリとして実行する。
    - この際Simulatorが引数形式ならば、同様の引数を与えて _preprocess.sh を実行する。この引数から実行パラメータを取得することができる。
    - 標準出力、標準エラー出力は _stdout.txt, _stderr.txt にそれぞれリダイレクトされる。
1. _preprocess.sh のリターンコードがノンゼロの場合には、SSHのセッションを切断しRunをfailedとする。
    - failedの時には、ワークディレクトリの内容をサーバーにコピーし、リモートサーバー上のファイルは削除する。
1. _preprocess.sh を削除する
1. シミュレーションジョブをサブミットする。

ただし、 Simulatorの pre_process_script のフィールドが空の場合には、上記3~6の手順は実行されない。

## Analyzerの登録と実行

ジョブの実行後、実行結果に対してポストプロセス（Analyzer）を定義することができる。
OACISで定義できるAnalyzerには２種類存在する。
一つは各個別のRunに対して実行されるもの、もう一つはParameterSet内のすべてのRunに対して行われるものである。
前者の例としては、シミュレーションのスナップショットデータから可視化を行う、時系列のシミュレーション結果に対してフーリエ変換する、などがあげられる。
後者の例は、複数のRunの統計平均と誤差を計算することなどがあげられる。
OACISの用語として、Analyzerによって得られた結果はAnalysisと呼ばれる。AnalyzerとAnalysisの関係は、SimulatorとRunの関係のようなものである。

Analyzerはサーバー上でバックグラウンドプロセスとして実行される。(すなわち、Host上で実行されない点がプリプロセスと異なる。)よってサーバー上でanalyzerが適切に動くように事前にセットアップする必要がある。
ユーザーはAnalyzerの登録時に実行されるコマンドを入力する。そのコマンドがバックグラウンドで呼ばれて解析が実行されることになる。
Simulatorの場合と同じように、実行日時や実行時間などの情報が保存され、結果はブラウザ経由で確認できる。

また、Analyzerは実行時に解析用のパラメータを指定して実行することもできる。
例えば、時系列データを解析するときに最初の何ステップを除外するか指定したい場合などに使える。
Analyzerの登録時にパラメータの定義を登録することができる。

実行時には新規にそのAnalyzer専用のワーキングディレクトリが作られ、そこでAnalyzerとして定義されたコマンドが実行される。
Simulatorの場合と同様にワーキングディレクトリ以下のファイルがそのままサーバー上に保存されるため、カレントディレクトリ以下に結果を出力するようにAnalyzerを実装する必要がある。
結果のファイルに `_output.json` というファイルが存在する場合に、パースされてデータベースに格納されるのもSimulatorと同様である。

解析対象となるRunの結果もワーキングディレクトリ以下に配置されるが、解析対象がRunかParameterSetかによって異なるため以下で個別に説明する。

### Runに対する解析

ここではRunに対する解析の例として、時系列データを出すシミュレーションのanalyzerとして、時系列をグラフにプロットすることを考える。
シミュレータが以下の形式のファイルをsample.datというファイル名で出力することとする。１列目が時刻、２列目がプロットするデータを表す。

```
1 0.25
2 0.3
3 0.4
```

Analyzerの実行時には、Runの結果は *_input/* というディレクトリに保存される。
Analyzerはそのディレクトリにあるファイルを解析できるように実装する。

例として、入力の時系列をgnuplotでプロットする。
次に示すようなgnuplot入力ファイルを作成し、どこかのパス（例として ~/path/to/plotfile.pltというパスにする）に保存する。

```
set term postscript eps
set output "sample.eps"
plot "_input/time_series.dat" w l
```

これでAnalyzerの準備ができたので、OACISに登録する
Simulatorの画面を開き、[About]タブをクリックするとAnalyzerを新規登録するためのリンク[New Analyzer]が表示される。
そのリンクをクリックすると下図のような登録画面が現れる。

![Analyzerの登録]({{ site.baseurl }}/images/new_analyzer.png){:width="400px"}

このページの入力フィールドにAnalyzerの情報を登録する。入力する項目は以下の通り。

|----------------------------|---------------------------------------------------------------------|
| フィールド                 | 説明                                                                |
|:---------------------------|:--------------------------------------------------------------------|
| Name                       | OACISの中で使われるAnalyzerの名前。任意の名前を指定できる。各Simulator内で一意でなくてはならない。
| Type                       | Runに対する解析(on_run)、ParameterSetに対する解析(on_parameter_set)のどちらかから選ぶ
| Definition of Parameters   | 解析時に指定するパラメータがあれば登録する。空でもよい。
| Command                    | Analyzerを実行するコマンド。
| Pring version command      | Analyzerのバージョンを標準出力に出力するコマンド。
| Auto Run                   | Runの終了後に解析が自動実行されるか指定する。
| Description                | Analyzerに対する説明。入力は任意。
|----------------------------|---------------------------------------------------------------------|

ここでは、Nameを"plot_timeseries"、Typeをon_run、Definition of Parametersは空のまま、Auto Runはnoを指定する。
コマンドには以下を入力する。

```
gnuplot ~/path/to/plotfile.plt
```

このようにAnalyzerを登録するとRunの実行後に"plot_timeseries"というAnalyzerを選択して実行できるようになる。
解析の結果は、runの結果同様にブラウザ上で閲覧することができる。

Auto Runのフラグは yes, no, first_run_onlyから選択できる。
各項目の説明は以下の通り。

- yes: 各Runが正常終了した場合に自動で解析が実行される。
- no : 自動で実行されない。
- first_run_only: 各ParameterSet内で最初に正常終了したRunに対してのみ自動実行される。データの可視化など、一つのRunに対してのみ実行したい解析処理に対して使用できる。

今回のサンプルでは示されていないが、パラメータを受け付けるAnalyzerの場合には `_input.json` というファイル内に解析のパラメータが記入される。
Runに対する解析の場合、 `_input.json` のフォーマットは以下の通りである。
"analysis_parameters", "simulation_parameters" はそれぞれ解析パラメータ、シミュレーションパラメータを表す。

```
{
 "analysis_parameters": {
   "x": 0.1,
   "y": 2
 },
 "simulation_parameters": {
   "L": 32,
   "T": 0.5
 }
}
```

### ParameterSetに対する解析

ParameterSetに対する解析もRunに対する解析とほぼ同様である。
ただし、_input/ディレクトリに保存される形式と `_input.json` の形式が異なる。
RunのIDの一覧が run_ids というキーに格納される。
Runの結果ファイルを参照するには `_input.json` からRunのIDの一覧を取得する処理をAnalyzer内で実装する。

`_input/` ディレクトリ内のファイルの構成は以下の通り

```
_input/
  #{run_id1}/
    xxx.txt
    yyy.txt       # run_id1 の結果ファイル
  #{run_id2}/
    xxx.txt
    yyy.txt
 .....
```

`_input.json` の形式は以下の通り

```
{
  "analysis_parameters": {
    "x": 0.1,
    "y": 2
  },
  "simulation_parameters": {
    "L": 32,
    "T": 0.5
  },
  "run_ids": [
    "run_id1",
    "run_id2",
    "run_id3"
  ]
}
```

AnalyzerからRunの結果ファイルを取得する例(言語：ruby)

```
require 'json'
require 'pathname'
persed = JSON.load(open('_input.json'))
RESULT_FILE_NAME = 'time_series.dat'
result_files = persed["run_ids"].map do |id|
  Pathname.new("_input").join(id).join(RESULT_FILE_NAME)
end
# => ["_input/526638c781e31e98cf000001/time_series.dat", "_input/526638c781e31e98cf000002/time_series.dat"]
```

ParaemterSetに対する解析の場合、Auto Runのフラグはyes, noの２択から選択可能である。
yesの場合、ParameterSet内のすべてのRunが :finished または :failed になったときに自動実行される。

### Analyzerのバージョンを記録する

Analyzer実行時に、どのバージョンのAnalyzerを実行したかをanalysisとひもづけてOACISに記録させておくことができる。
バージョンを記録することにより、例えば、あるバージョンのanalysisを一括削除などの操作ができる様になる。

Analyzerのバージョンを保存するには、Analyzerのバージョンを出力させるコマンドをOACISに登録する。
例えば、

```
echo "v0.1.0"
```

というコマンドでバージョン情報を出力する場合、このコマンドをAnalyzer登録時に"Print version command" というフィールドに入力する。
その他、登録できるコマンドの書式は、 :ref:`シミュレーターのバージョンを記録する<manage_simulator_version>` を参照。


